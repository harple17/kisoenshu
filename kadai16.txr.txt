【プログラムの説明】
・charBubbleSort
100*64の文字配列cと、int型変数nを引数とする。
コピー用にtmpを用意。
0からsize-2まで1ずつ増加するiのforループに入る。
このループでどこまで二重ループを続けるか決める。
二重目のforループでsize-1からi+1まで1ずつ減るjのforループに入る。
cのj-1番目の要素がj番目の要素より小さければ入れ替える。今回は比較にstrcmpを用いた。
ここまでがjのループ。
jのループが終わればiのループを最後行う。
・charSelectSort
100*64の文字配列cと、int型変数nを引数とする。
コピー用にtmpを用意。
0からsize-2まで1ずつ増加するiのforループに入る。
変数maxを用意し、iを記録。ここに最小の要素を記録していく。
二重目のforループでi+1からsize-1まで1ずつ増加するjのforループに入る。
cのmin番目の要素よりj番目が小さければminをjに変更.ここまでがjのループ。
cのi番目の要素とmin番目の要素を入れ替え。ここまでがiのループ。
・charInsertSort
100*64の文字配列cと、int型変数nを引数とする。
1からn-1まで1ずつ増加するiのforループに入る。
保存用にtmpを用意しcのi番目の文字列をコピー。この場所にふさわしい要素を探す。
二重目のforループでiから1まで、j-1番目の要素が保存した要素より大きい間は1ずつ減少するjのforループに入る。
cのj番目にj-1番目の要素を代入。ずらしていく。ここまでがjのループ。
j番目に記録した要素を代入。
これをiのループで繰り返す。
【プログラムの説明・追記】
・mystrcmp
今回の文字列比較にはstrcmpが使えないので、今回の問題設定に対応した文字列比較関数を用意。
まずは文字列の長さを測って第一引数の方が大きければ正の値、第二引数の方が大きければ負の値を返す。
文字列の長さが等しければ、第一と第二引数で文字が異なる番号を記録。
今回の問題設定に合わせて、異なる部分がどんな文字かでステータスを付ける。大文字なら2,小文字なら1,数字なら0。
これで↑同様返り値を決定。
第一と第二引数で再びステータスが等しくなれば、残りは単純に内容を文字として比較。
↑同様返り値を決定。ここまでやっても決まらなければ、文字列として等しいので0を返す。
【感想】
最初は手が出なかった。二次元配列にすればいいことに気づくのに時間がかかった。ただもう二次元配列にすることがわかれば対して難しくない：……はず。課題15の焼き直し。
strcmpが便利すぎた。というかstrcmpに合わせて課題が設定されているのかな、と思った。
【感想・追記】
テスト不十分でstrcmpが今回不適切であることがわかっていなかった。完成した気になってテストを十分に行っていない時があるのでそれをやめる。