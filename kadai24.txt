【プログラムの説明】
・SCORE構造体
STUDENT構造体へのポインタp_student_arr、SUBJECT構造体へのポインタp_subject_arr、SCORE構造体へのポインタp_student、p_subject、int型変数scoreを持つ。
・STUDENT構造体
SCORE構造体へのポインタp_scoreと学籍番号、氏、名、電話番号を格納するchar型配列を持つ。
・SUBJECT構造体
SCORE構造体へのポインタp_scoreと教科名を格納するchar型配列を持つ。
・init関数
初期化関数。生徒数と教科数の大域変数を0にして、それぞれの点数へのポインタをNULLに。
・addStudent関数
for文でEMPTYという文字列の学籍番号を探し、あればiはその要素のキーを記録。ないのであればiはNUM_OF_STUDENT(これまでで登録された生徒の最大数)に。
(EMPTY文字列はのちの削除関数を使用した場合、STUDENT構造体の各学生情報に格納される。再び生徒を登録する際にはEMPTY文字列を持つSTUDENT配列の要素が優先的に使用される)
STUDENT配列のi番目の要素のメンバに学生情報を記録。
iがNUM_OF_STUDENTであればEMPTYがなかったので次も記録できるように最大数NUM_OF_STUDENTを増やす。
・addSubject関数
addStudent関数のSUBJECT構造体版。
・regSub関数
学生登録番号reg_num_stu、教科登録番号reg_num_subの点数scoreを記録。
いずれかの番号が既存の配列の最大数を超えていれば登録不可。
SCORE構造体へのポインタpを用いて構造体分のメモリを確保。pを用いてポインタを付け替えてSTUDENT[reg_num_stu]のSCOREポインタ、SUBJECT[reg_num_sub]のSCOREポインタの直後に挿入。
・delSub関数
学生登録番号reg_num_stu、教科登録番号reg_num_subの記録を破棄。
SCORE構造体へのポインタpを用意し、STUDENT[reg_num_stu]のSCOREポインタを代入。また同じくポインタtmpも用意。
pの指す構造体のメンバp_subject_arrがSUBJECT[reg_num_sub]を指すまでpを次のp_studentへ変えながら探索。
ポインタの付け替えのタイミングでpより一つ前のポインタが必要になるためtmpに記録。
pがNULLとなれば探索失敗。
もしpが移動していなければSTUDENT[reg_num_stu]のSCOREへのポインタをpのp_studentに変更。
それ以外ならtmpのp_studentをpのp_studentに変更。
同様にSUBJECT側もポインタを付け替えて外す。
最後にpをfreeする。
・deleteStudent関数
学生登録番号reg_num_stuのデータを全て削除する。
SCOREポインタpを用意。
forループでiをNUM_OF_STUDENTまで移動させる。
このループではpをSUBJECT[reg_num_sub]のSCOREポインタにし、二重目while文でpがNULLになるまでの間、pのp_student_arr要素がSTUDENT[i]を指せば登録されているので先ほどのdelSubを再利用して削除する。
STUDENT[reg_num_stu]の各メンバはEMPTY文字列を持つようにする。
・deleteSubject関数
deleteStudent関数のSUBJECT版。
・showRegisteredStudent関数
登録されている学生の全情報を表示。
・showRegisteredSubject関数
登録されている教科の全情報を表示。
・printIndAveandStd関数
学生登録番号reg_num_stuの平均、標準偏差を表示。
SCOREポインタpを用意。pがNULLならscoreなし。
pがNULLになるまでの間pを動かして、sumで点数の合計、pow2_sumで点数の二乗の合計、cで要素の数を記録。
上で記録した情報を用いて平均と分散を表示。
・printSubAveandStd関数
printIndAveandStdの教科版。
【感想】
なかなか複雑で難しかった。ここまでしないとメモリの節約にならないのかと驚いた。今は十分なメモリを持つコンピュータばかりだが、以前はこのような構造を編み出してうまくやり取りしていたのだとおもうと感慨深い。
とくにdelSubは非常に手間取った。アイデアを書き出してみるとうまく整理できたので書き出してみることは重要だと感じた。