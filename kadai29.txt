【プログラムの説明】
createrandnum関数は課題28のものなので省略。
・shellsort関数
挿入ソートの改良であるシェルソートを行う関数。
h飛び飛びで挿入ソートを行う。最初のfor文で最大のhを決める。
hが正の間、iがhからn-1まで、jにiを代入しjがh以上かつj-h番目の要素がj番目の要素より大きい場合スワップを繰り返す。スワップしたときjをh減らす。
jがh以上の条件はj-hが範囲外にならないようにするためである。こうしてh飛び飛びの挿入ソートを行う。iがn-1以上になったらhを3で割る。
・partition関数
クイックソートのための分割関数。
getmid関数で左端、右端、真ん中の要素から中央値を取り出して、枢軸にする。この時順序関係を保つために枢軸は右端にスワップ。
ここから繰り返しに入る。
枢軸より大きい要素を見つけ数列のi番目とし、枢軸より小さい要素を見つけ数列のj番目とする。このときiがj以上なら分割済みなのでループを抜ける。
i番目とj番目をスワップ。ここまでを繰り返す。
最後にi番目と右端をスワップして枢軸を適切な位置に移動。このiを返す。
・quicksort関数
クイックソートを行う関数。ネスト対策にスタック構造を用いている。
配列lに整列したい配列の左端の番号、rには右端の番号を記録。最初は0とn-1。
spでスタックを管理する。0とn-1が記録されたので1を代入。
spが正の間以下を繰り返す。
spを1減らして左端と右端の番号を取り出す。右端の番号が左端の番号以下なら分割できないので次の番号を取り出す。
partitionで配列を分割、分割した左側と右側で長さを比べて、短い方を先に処理。スタックのオーバーフローを防ぐ。
このときスタックなので後で入れた方が先に処理されることに注意。
・mergesort_arr関数
配列版マージソート。
左端の番号が右端の番号以上なら処理しない。
左端と右端の番号の平均をとって分割。左端から分割したところまで、分割したところから右端までを再帰的に処理。
配列の左から分割までを作業用配列に左側からコピー、配列の分割から右までを作業用配列に右側からコピー。
作業用配列の左側と右側から小さい要素を取り出していって配列を併合。
【感想】
今までの基本的なソートに比べてコードが比較的長くなっていて、定数係数が大きいということがなんとなく理解できた。でもシェルソートは挿入ソートにほんの少し加えるだけなのに速くなるのが不思議。時間も計測してみたが400ぐらいだと僕の環境ではクイックソートよりシェルソートの方が速かったし、整列アルゴリズムは奥が深いと感じた。