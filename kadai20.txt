【プログラムの説明】
NODE構造体をNODEポインタnextとint型valueで定義.
・create関数
int型のdataを受け取る。
NODEポインタpにmallocで確保したNODE分のメモリを指すアドレスを格納.
pのnextをNULLに、pのvalueをdataにしてpを返す.
・createEmpty関数(空集合にする関数)
NODEポインタheaderを受け取り、headerから始まるリストを空にする.
NODEポインタpにheaderのnextアドレスを格納.
pがNULLでない限り、pのnextアドレスをtmpに保存して、pをfree、pにtmpを代入.
pがNULLになってループを抜けた後、最後にpをfree.
headerの次をNULLにしなおしてリストをheaderのみにする.
・isincluded関数
NODEポインタheaderとint型xを受け取る.
NODEポインタpにheaderのnextアドレスを格納.
pがNULLでない限り、「pのvalueがxと一致すれば1を返す」と「pをpのnextにする」を続ける.
最後に0を返す.
・createUnion関数(和集合を作る関数)
NODEポインタheader1,header2を受け取る.
NODEポインタheaderにheadをcreateしたアドレスを格納.
NODEポインタp1にheader1のnext,NODEポインタp2にheader2のnext,NODEポインタpにheaderを格納.
p1がNULLでないかぎり、「pのnextにp1のvalueをcreateしたアドレスを追加し、pをpのnextに、p1をp1のnextにする」を繰り返す.
p2がNULLでないかぎり、「headerから始まるリストにp2のvalueがなければpのnextにp2のvalueをcreateしたアドレスを追加し、pをpのnextにする」と「p1をp1のnextにする」を繰り返す.
headerを返す.
・createDef関数(差集合を作る関数)
NODEポインタheader1,header2を受け取る.
NODEポインタheaderにheadをcreateしたアドレスを格納.
NODEポインタp1にheader1のnext,NODEポインタpにheaderを格納.
p1がNULLでないかぎり、「header2から始まるリストにp1のvalueがなければpのnextにp1のvalueをcreateしたアドレスを追加し、pをpのnextにする」と「p1をp1のnextにする」を繰り返す.
headerを返す.
・createProd関数(積集合を作る関数)
NODEポインタheader1,header2を受け取る.
NODEポインタheaderにheadをcreateしたアドレスを格納.
NODEポインタp1にheader1のnext,NODEポインタpにheaderを格納.
p1がNULLでないかぎり、「header2から始まるリストにp1のvalueがあればpのnextにp1のvalueをcreateしたアドレスを追加し、pをpのnextにする」と「p1をp1のnextにする」を繰り返す.
headerを返す.
・add関数(要素の追加)
NODEポインタheaderとint型data、int型posを受け取る.
headerから始まるリストにdataがあれば既に集合に要素があることを表示して終了.
なければ、NODEポインタpにdataをcreateしたアドレスを格納.
NODEポインタinsにheaderを格納し、posの数だけinsをすすめる.
insのnextをtmpに格納し、insのnextをpに、pのnextをtmp(もとのinsのnext)にする.
headerから始まるリストのpos番目の次にdataを挿入することになる.
・delete関数(要素の削除)
NODEポインタheaderとint型posを受け取る.
NODEポインタpにheaderを格納.
posの数だけpを進める.
tmpにpのnextを格納し、pのnextをtmpのnext(pのnextのnext)に.
tmpのnextをNULLにしてtmpを返す.
headerから始まるリストのpos番目の次の要素を削除できる.
・assignset関数
NODEポインタheader1,header2を受け取る.
header2から始まるリストを空にする.
header1から始まるリストの要素をadd関数を用いてheader2から始まるリストに追加.
・setcmp関数
NODEポインタheader1,header2を受け取る.
int型配列a1,a2を用意、0で初期化.
header1から始まるリストの要素を調べ、その要素があればa1のその要素番目を1にする.
header2も同様.
int型flagを0で初期化.
a1とa2を前から順に調べ、同じ番目で0と1が異なる(集合の要素が違う)場合はflagを1にしてbreak.
flagを返す.(1なら同一でない、0なら同一の集合)
find関数
NODEポインタheaderとint型xを受け取る.
NODEポインタpを用意し、headerのnextから始めて「pがNULLの間、pのvalueがxと一致すればbreak,pをpのnextに」を繰り返す.
pを返す.
【感想】
この前の問題で求められていたのはこういうことですかね。
それはそれとして、なかなか疲れました。
集合なので既に含まれている要素は追加しなくていいこととかに注意しました。isinclude関数はそのための関数です。
setcmpはうまく配列を使って判定するようにできたと思います。
あとは集合の代入がいまいちよくわからないので不安です。