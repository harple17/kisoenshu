【プログラムの説明】
・add関数
双方向リストのヘッダへのポインタheaderを受け取って、headerの前の要素が次に指す要素をmallocしたpにして、pが前に指す要素をheaderの前の要素にする。
pが次に指す要素をheaderにして、headerが前に指す要素をpにする。
このようにpの指す要素を追加する。
なお、pへの個人データ入力も受け付ける。
・delete関数
双方向リストのheaderとint型変数posを受け取って、posの数だけpを次の要素へ移動、pがheaderでなければ、pの前の要素が次に指す要素をpの次の要素に、pの次の要素が前に指す要素をpの前の要素にする。
pが次に指す要素、pが前に指す要素をpにしてpを返す。
このように要素を削除する。
・search関数
headerとint型変数mode、文字列c、構造体型の二重ポインタarrayを受け取る。二重ポインタはポインタを格納する配列である。
構造体型ポインタpにheaderを代入。modeの値によって検索の項目を変更。
例えば1なら、以下の様に学生番号を検索する。
pをpの次の要素を指すように変更し、pの指す構造体の学生番号メンバがcと一致すれば、そのアドレスをarrayに格納していく。pの次がheaderに戻ってくるまで続ける。
各項目に対し同様に検索。
・sort関数
headerとmode、arrayを受け取る。型はsearch関数と同じ。
構造体型ポインタp1にheaderを代入。構造体型ポインタtmpとp2を用意。searchと同様modeの値でソートの項目を変更。
例えば1なら、いかの様に学生番号を検索。
一重目のループでp1をp1の次の要素を指すように変更し、tmpにp1を代入。p2にp1の次を代入。
二重目のループでp2がheaderでなければtmpとp2の項目の内容を比較し、小さい方をtmpに格納。p2を次へ。ここまでが二重目ループで、二重目のループはp2がp1まで戻ってきたら終了。p2がheaderでない条件を付けているのはp1まで戻ってくる時にheaderを通るからである。
tmpの内容がまだソートされていない内容であれば、記録。ここまでが一重目のループ。
各項目に対し同様にソート。なお、これは選択ソートを参考にしている。
・showdata関数
headerとmodeを受け取る。modeによって追加順か逆追加順か決める。
構造体型ポインタtmpにheaderを代入。
modeが1ならtmpを次の要素にして、tmpの次がheaderになるまで各項目を表示するという内容のdo-while文を機能させる。
modeが2のときは前を指すように変えればよい。
tmpがheaderのままなら要素なしと判断してemptyを表示。
【説明追記】
tmpがheaderのとき飛ばすことを失念していた。
【感想】
連結リストに比べて双方向リストの方が扱いやすいことが学べた。構造体ってメンバの指定が必要なので同じ機能を何度も書いたので冗長になってしまったが、これも防げるんだろうか。特にsortは難しかった。もともとのリストをソートしているわけではないので、結局一周回って来なければいけないことに気づくのが遅れたため大幅に時間ロスをくらった。if文で無理やり記録させたが、これももっときれいに書けるようになりたい。