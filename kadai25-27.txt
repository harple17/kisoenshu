【プログラムの説明】
・insert関数
int型で番号、char型で名前を受け取る。
NODE構造体へのポインタのポインタpとポインタnewを用意。pが必要なのは挿入の際に一つ前のポインタがわからなければいけないからである。
pをrootへのポインタとして初期化。
pの中身がNULLになるまで、次の操作を繰り返す。
pの中身のメンバnumが受け取った番号と等しければ、NULLを返す。numが受け取った番号より小さければpを右へ、大きければ左へ。
newにはmallocでメモリを確保した場所を指すポインタを格納し、newのleft、rightをNULLに、numを受け取った番号に、nameを受け取った名前に変更。
最後にpの中身をnewにして挿入。
・search関数
int型で番号を受け取る。
NODE構造体へのポインタpを用意。後はinsert関数の探索法と同じ。
番号が見つかればそのポインタを返し、見つからなければNULLを返す。
・deletemin関数
主に後述のdelete関数で用いる。
その部分木の最小要素を削除する。
NODE構造体へのポインタのポインタpを受け取り、pの中身のメンバleftがNULLになるまでpをpの中身のメンバleftを指すように変更。
xにpの中身を保存して、pの中身をpの中身のメンバrightに変更して削除。xを返す。
・delete関数
insertと同様に探索。見つかったとき、葉ならそのまま削除。片方に子をもつならポインタをその子を指すように繋ぎ変えて削除。子を二つ持つならその右側の部分木の最小要素を削除して代わりにつなぎなおす。
保存したものをfreeして削除。削除後に1を返して削除完了。
・count関数
ノードの数を数える。
NODE構造体へのポインタpを受け取って、pがNULLなら0を返し、それ以外なら左部分木と右部分木を再帰的にcount。
それらのcountの和に1加えたものを返す。
・preorder関数
行きがけ順でノードを表示。
先に表示を行って、左部分木、右部分木の順に動く。
・inorder関数
通りがけ順でノードを表示。
左部分木へ移動し、表示。その後に右部分木へ。
・postorder関数
帰りがけ順でノードを表示。
左部分木右部分木へ移動し、表示。
・height関数
countとほぼ同じ、ただ返すときに左部分木と右部分木の高さの大きい方を返す。
感想
二分探索木の基本が学べたのは勿論、再帰関数も深めることができたと思う。どちらかというと二分探索より再帰の考え方の方が苦しんだ。ソートのための構造だと思っていたので、データベースとしても利用できるのは驚いた。