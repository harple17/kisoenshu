【プログラムの説明】
西暦、月、日を引数とし、曜日を返す(日曜を0、月曜を1、…土曜を6とする)関数z_fmと西暦を受け取りうるう年なら1を、そうでなければ0を返す関数isleapを定義。
int型配列end_of_monthに毎月の終わりの日数を記録しておく。
西暦の入力を受け、isleapが正であれば2月の終わりの日end_of_month[1]をうるう年用の29に書き換える。

int型配列buffを用意してすべての要素を0にして初期化し、入力された西暦に対応する日を代入する。buffは12(月の数)×6(ひと月に存在得る週数の最大値)×7(曜日の数)の三次元配列である。
これでいったん配列上にカレンダーを作成する。
例えば西暦2000年1月1日であれば、z_fmを用いて曜日がわかるのでbuff[0][0][z_fmの返り値]=1のように代入していく。
2000/01/03は1月の2週目になるのでbuff[0][1][z_fmの返り値]=3となり、このように繰り返すと配列の中でカレンダーができる。(数値が代入されていないところは0)

次にカレンダーを表示していく。まず一重目のループで行の数だけ同じ動作を繰り返す。(今回は月の数12を1行に表示するカレンダーの数3で割った4が行の数)
二重目のループは3つあり、別々に処理する。
1つ目で月を出力する。一行には3月分出力。
改行して2つ目のループで3月分の月～日を出力。さらに改行。
3つ目のループには三重目のループがあり、月の1週目かそれ以外かで処理を分ける。
1周目のときは、その月の1日目の曜日番号まで半角スペース3つを繰り返し、それ以降はbuffに記録されている日を出力する。これを1行に表示するカレンダーの数だけくりかえす。
月の2週目以降は、end_of_monthを利用しその月が月の終わりになるまでbuffに保存されている日を出力する。月末より大きくなればスペース3つを出力する。これを1行に表示するカレンダーの数だけくりかえす。
改行して、一重目のループを繰り返す。

【感想】
難しかった。説明も難しい。コードを見てもらいながらならやっと理解できるだろう説明しかできないのでもっと説明能力あげておかないといけないと思った。
課題4ではカレンダーの表示がすごく簡単だったのに、これを横に表示するだけでこんなに難しくなるのかと驚いた。
でも、マクロ定義によってNを変えれば(12の約数であるという制限は残るが)一行に表示するカレンダーの数を変えられるように一般化できてよかった。
12の約数でなくても表示できるようにしたい。






